1. ### Многопоточный подход, особенности

Многопоточность в Java позволяет асинхронное выполнение нескольких частей программы, что может значительно повысить её эффективность, особенно на многопроцессорных и многоядерных системах. Основная сложность многопоточности заключается в правильном управлении доступом к общим ресурсам и координации между потоками. Использование механизмов синхронизации, таких как `synchronized` блоки и классы из пакета `java.util.concurrent`, помогает предотвратить проблемы вроде гонки за ресурсы (race conditions), взаимных блокировок (deadlocks) и условий состязания (race conditions).

2. ### Класс Thread для запуска потоков

Класс `Thread` предоставляет базовую инфраструктуру для работы с потоками в Java. Для создания нового потока, класс, представляющий задачу, должен либо наследоваться от `Thread`, либо реализовывать интерфейс `Runnable`. В первом случае, логика задачи реализуется путём переопределения метода `run`. Поток запускается вызовом метода `start`, который в свою очередь вызывает метод `run`. Важно отметить, что прямой вызов `run` не приведёт к многопоточному выполнению, а выполнит задачу в текущем потоке.

3. ### Интерфейс Runnable для запуска потоков

Использование интерфейса `Runnable` предоставляет более гибкий способ работы с потоками, поскольку он позволяет классу оставаться наследником другого класса. Класс, реализующий `Runnable`, должен реализовать метод `run`, в котором определена логика задачи. Затем экземпляр этого класса можно передать в конструктор `Thread`, после чего поток запускается вызовом `start` на объекте `Thread`. Этот подход улучшает возможность повторного использования кода и поддерживает принципы объектно-ориентированного проектирования.

4. ### Класс Thread для управления потоками

Помимо запуска потоков, класс `Thread` предлагает различные методы для их управления. Методы вроде `interrupt`, `join`, `sleep` позволяют контролировать выполнение потоков, останавливая их, ожидая их завершения или приостанавливая на определённый период. Это играет ключевую роль в точном и эффективном управлении параллельным выполнением задач в многопоточной среде.

5. ### Понятие группы потоков

Группы потоков в Java обеспечивают способ управления коллекцией потоков как единым целым. Это может быть полезно для коллективного управления группами связанных потоков, например, для установления единой политики обработки исключений, приостановки, возобновления работы или одновременного прерывания всех потоков в группе. Каждый поток может быть частью только одной группы потоков, и группы могут также включать в себя другие группы, формируя иерархию.

6. ### Управление группой потоков

В Java группы потоков представляют собой способ управления набором потоков как единой сущностью. Они позволяют группировать потоки по функциональности или ресурсам, которыми они пользуются, что упрощает их управление и мониторинг. Например, можно прервать все потоки в группе, не обращаясь к каждому из них индивидуально. Создание группы потоков происходит через инстанцирование объекта класса `ThreadGroup`, в который затем можно добавлять потоки. Методы группы потоков, такие как `interrupt()`, позволяют применять операции ко всем потокам в группе сразу, что упрощает обработку многопоточности в больших и сложных приложениях.

7. ### Потоки-демоны

Потоки-демоны в Java — это служебные потоки, которые предназначены для выполнения фоновых задач в поддержку работы других потоков. Отличительной чертой демон-потоков является то, что JVM не дожидается их завершения перед тем как выйти, то есть если все не-демон потоки завершили свою работу, JVM прекратит выполнение, даже если демон-потоки все еще активны. Чтобы сделать поток демоном, используется метод `setDaemon(true)` объекта `Thread` до его запуска. Потоки-демоны часто используются для выполнения рутинных задач вроде сбора мусора, автоматического сохранения и других поддерживающих операций.

8. ### Проблемы совместного использования ресурсов

В многопоточных приложениях Java, потоки часто разделяют ресурсы, такие как файлы, данные в памяти и т.д. Это может привести к проблемам синхронизации, когда несколько потоков пытаются одновременно читать и записывать одни и те же данные. Основные проблемы, связанные с совместным использованием ресурсов, включают условия гонки (race conditions), когда результаты выполнения программы зависят от того, в каком порядке выполняются потоки, и взаимные блокировки (deadlocks), когда два или более потоков блокируют друг друга, ожидая освобождения ресурсов. Решение этих проблем часто требует использования техник синхронизации.

9. ### Синхронизированный блок

Синхронизированный блок в Java используется для обеспечения того, что только один поток может исполнять определенный блок кода в данный момент времени. Синхронизированный блок помещается внутрь метода и обрамляется ключевым словом `synchronized`, за которым следует объект-монитор, используемый в качестве замка. Внутри такого блока поток имеет эксклюзивный доступ к ресурсам, ассоциированным с монитором, что предотвращает проблемы совместного доступа. Это мощный механизм для управления доступом к критическим секциям кода, но его использование должно быть осторожным, чтобы избежать снижения производительности и взаимных блокировок.


10. ### Синхронизированный метод

Синхронизированный метод в Java автоматически блокирует доступ к методу для любых других потоков, пока один поток его исполняет. Это достигается путем добавления ключевого слова `synchronized` к объявлению метода. В контексте нестатического метода, монитором для синхронизации является экземпляр объекта, в контексте статического метода — класс объекта. Синхронизированные методы упрощают синхронизацию, особенно когда весь метод должен быть защищен от одновременного доступа, но также могут вести к уменьшению параллельности и увеличению времени ожидания потоками доступа к методу.

11. ### Поля volatile

Поля, объявленные в Java как `volatile`, используются для обозначения переменных, значения которых могут быть изменены различными потоками. Ключевое слово `volatile` гарантирует, что чтение и запись значения переменной всегда производится в основную память, тем самым обеспечивая видимость изменений между потоками без необходимости использования синхронизации. Однако, `volatile` не блокирует потоки и не обеспечивает атомарность сложных операций (например, инкрементации). Это значит, что `volatile` подходит для простых флагов состояния и булевых переменных, но не для ситуаций, когда нужна полная синхронизация доступа.

12. ### Методы класса Object для синхронизации потоков

В Java каждый объект имеет встроенную блокировку и методы синхронизации, которые могут использоваться для координации взаимодействия между потоками. Основные методы синхронизации, определенные в классе `Object`, включают:

- `wait()`: заставляет текущий поток ожидать до тех пор, пока другой поток не вызовет `notify()` или `notifyAll()` для этого объекта.
- `notify()`: пробуждает один из потоков, ожидающих на этом объекте. Выбор потока происходит произвольно.
- `notifyAll()`: пробуждает все потоки, ожидающие на этом объекте.

Эти методы могут быть использованы только в синхронизированных блоках или методах, и они играют ключевую роль в реализации ожидания/уведомления паттерна в многопоточных приложениях.

13. ### Правила прерывания потоков, запрещенные методы

Прерывание потоков в Java используется для остановки или изменения поведения потока из другого потока. Для этого поток-источник вызывает метод `interrupt()` на потоке-цели. Поток-цель может периодически проверять свой прерываемый статус с помощью `Thread.interrupted()` или `isInterrupted()` и соответствующим образом реагировать на прерывание.

Существуют методы, которые ранее использовались для остановки потоков, но теперь считаются небезопасными и устаревшими (deprecated), такие как:

- `stop()`: принудительно останавливает поток, не давая ему корректно завершить выполняемые операции, что может привести к несогласованному состоянию данных.
- `suspend()`: приостанавливает выполнение потока, не освобождая заблокированные им ресурсы, что может привести к взаимным блокировкам.
- `resume()`: возобновляет выполнение потока, ранее приостановленного с помощью `suspend()`.

Использование этих методов не рекомендуется из-за потенциальных проблем с безопасностью и взаимными блокировками. Вместо них рекомендуется использовать прерывания и другие безопасные механизмы синхронизации.